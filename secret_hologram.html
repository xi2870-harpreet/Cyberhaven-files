<!--
=======================================================
Cyberhaven Confidential Technology
Project: C7-THN-99321 - Quantum Visual Identity Engine
File: HologramRenderer.html
Author: tiko@cyberhaven.io
Proprietary Algorithm: encodeVisualSignatureInterference()
Copyright Â© 2025 Cyberhaven Inc. All rights reserved.
Unauthorized use, reproduction, or reverse engineering is prohibited.
=======================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="tiko@cyberhaven.io">
    <meta name="classification" content="Confidential - Cyberhaven IP">
    <meta name="project-code" content="C7-THN-99321-PROTOTYPE">
    <meta name="sensitivity-level" content="Level-4: Holographic R&D">
    <title>Cyberhaven 3D Hologram - Self-Contained</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        /**
         * Proprietary Visual Rendering Module
         * Author: tiko@cyberhaven.io
         * Project: C7-THN-99321
         * Date: 2025-06-19
         * Classification: Confidential - Cyberhaven Use Only
         * UUID: 6c7e4cda-81b0-4c77-8929-c3cf35e52af1
         * 
         * This script contains proprietary visualization
         * intended for internal holographic identity verification use only.
         * Reverse engineering is strictly prohibited.
         */
        console.info("Maintained by Tiko (tiko@cyberhaven.io)");
        // Internal holographic telemetry pipeline hook
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // NOTE: Token generated from HologramPipelineAuthenticator v4.2
        const internalTrackingToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
        
        // --- GOOGLE DRIVE IMAGE URL ---
        const logoImageDataUrl = "https://lh3.googleusercontent.com/d/1e7x5OpHE9nOstOE2NUlZ9uwQRRUdkvFL";
        // --- END GOOGLE DRIVE IMAGE URL ---


        let scene, camera, renderer, composer, logoGroup, protonGroup;
        const protons = [];
        const protonCount = 200;
        const protonSphereRadius = 18; // Increased to match larger hologram
        const clock = new THREE.Clock();

        function init() {
            scene = new THREE.Scene();
            
            // Set plain black background
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20); // Centered for full height hologram

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Add ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            // Add subtle directional light
            const directionalLight = new THREE.DirectionalLight(0x80c0ff, 0.5);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create ground platform (positioned lower for full height hologram)
            const platformGeometry = new THREE.CylinderGeometry(20, 20, 0.5, 32);
            const platformMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.2,
                emissive: 0x001122,
                emissiveIntensity: 0.1
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -12;
            platform.receiveShadow = true;
            scene.add(platform);

            // Add floating ambient particles
            createAmbientParticles();

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.3, 0.5, 0.98
            );
            composer.addPass(bloomPass);

            // --- Load Texture from Data URL ---
            const textureLoader = new THREE.TextureLoader();
            const logoTexture = textureLoader.load(
                logoImageDataUrl, // Use the Google Drive URL
                (texture) => {
                    console.log("Texture loaded successfully from Google Drive");
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.needsUpdate = true;
                    createLogoHologram(texture);
                    createProtons();
                },
                (progress) => {
                    console.log('Loading progress:', progress);
                },
                (error) => {
                    console.error('Error loading texture from Google Drive:', error);
                    // Fallback to a simple colored plane if image fails to load
                    console.log('Creating fallback colored hologram...');
                    createFallbackHologram();
                    createProtons();
                }
            );
            // --- End Texture Loading ---

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createLogoHologram(texture) {
            // Make hologram full height - calculate size based on camera view
            const aspectRatio = texture.image.width / texture.image.height;
            const fov = camera.fov * Math.PI / 180; // Convert to radians
            const distance = camera.position.z;
            
            // Calculate full viewport height at hologram distance
            const viewportHeight = 2 * Math.tan(fov / 2) * distance;
            const planeHeight = viewportHeight * 0.95; // Use 95% to keep full image visible
            const planeWidth = planeHeight * aspectRatio;
            
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            
            // Create scanline shader material for holographic effect
            const hologramMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: texture },
                    time: { value: 0.0 },
                    opacity: { value: 1.0 },
                    scanlineIntensity: { value: 0.01 },
                    interferenceIntensity: { value: 0.001 },
                    interferencePhase: { value: 0.0 },
                    layerDepth: { value: 0.0 },
                    verticalFade: { value: 1.0 },
                    distortionAmount: { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float time;
                    uniform float opacity;
                    uniform float scanlineIntensity;
                    uniform float interferenceIntensity;
                    uniform float interferencePhase;
                    uniform float layerDepth;
                    uniform float verticalFade;
                    uniform float distortionAmount;
                    varying vec2 vUv;
                    
                    // Pseudo-random function for speckle patterns
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    // Noise function for speckle
                    float noise(vec2 st) {
                        vec2 i = floor(st);
                        vec2 f = fract(st);
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }
                    
                    void main() {
                        // Apply distortion effect during transitions
                        vec2 distortedUv = vUv;
                        if (distortionAmount > 0.0) {
                            // Horizontal wave distortion
                            float waveDistortion = sin(vUv.y * 20.0 + time * 8.0) * distortionAmount * 0.02;
                            distortedUv.x += waveDistortion;
                            
                            // Vertical compression/expansion
                            float verticalDistortion = sin(time * 6.0) * distortionAmount * 0.01;
                            distortedUv.y += verticalDistortion;
                        }
                        
                        // Vertical fade effect (bottom to top) - fade to black, not white
                        float verticalMask = smoothstep(0.0, verticalFade, vUv.y);
                        
                        // Chromatic aberration offset based on distance from center
                        vec2 center = vec2(0.5, 0.5);
                        float distFromCenter = length(distortedUv - center);
                        float chromaticOffset = distFromCenter * 0.003 * (1.0 + layerDepth * 0.5);
                        
                        // Sample RGB channels with chromatic aberration and distortion
                        float r = texture2D(tDiffuse, distortedUv + vec2(chromaticOffset, 0.0)).r;
                        float g = texture2D(tDiffuse, distortedUv).g;
                        float b = texture2D(tDiffuse, distortedUv - vec2(chromaticOffset, 0.0)).b;
                        float alpha = texture2D(tDiffuse, distortedUv).a;
                        
                        vec3 texelColor = vec3(r, g, b);
                        
                        // Subtle speckle pattern
                        float speckleScale = 150.0 + layerDepth * 50.0;
                        float speckle = noise(vUv * speckleScale + time * 0.1);
                        speckle = pow(speckle, 3.0) * 0.05;
                        
                        // Calm scanlines
                        float scanlineFreq = 400.0 + layerDepth * 50.0;
                        float scanline = sin(vUv.y * scanlineFreq + time * 2.0) * scanlineIntensity;
                        
                        // Layer-specific interference patterns
                        float interference = sin(vUv.x * 800.0 + time * 3.0 + interferencePhase) * 
                                           sin(vUv.y * 900.0 + time * 2.5 + interferencePhase * 0.7) * 
                                           interferenceIntensity;
                        
                        // Fresnel effect based on viewing angle
                        float fresnel = pow(1.0 - abs(dot(normalize(vec3(vUv - 0.5, 0.0)), vec3(0.0, 0.0, 1.0))), 2.0);
                        fresnel = mix(0.1, 0.9, fresnel);
                        
                        // Depth-based color shift - darker colors, no white
                        vec3 depthTint = mix(
                            vec3(0.0, 0.1, 0.2),  // Front layers: darker blue
                            vec3(0.05, 0.15, 0.1),  // Back layers: darker cyan-green
                            clamp(layerDepth / 5.0, 0.0, 1.0)
                        );
                        
                        // Enhanced edge diffraction effect
                        float edgeFactor = min(
                            min(vUv.x, 1.0 - vUv.x),
                            min(vUv.y, 1.0 - vUv.y)
                        );
                        float diffraction = smoothstep(0.0, 0.1, edgeFactor);
                        
                        // Subtle diffraction at edges
                        vec3 diffractionColor = vec3(
                            sin(edgeFactor * 20.0 + time * 2.0) * 0.1,
                            sin(edgeFactor * 20.0 + time * 2.0 + 2.094) * 0.1,
                            sin(edgeFactor * 20.0 + time * 2.0 + 4.188) * 0.1
                        ) * (1.0 - diffraction) * 0.2;
                        
                        // Color modulation for holographic feel - prevent white
                        vec3 hologramColor = texelColor;
                        
                        // Apply vertical fade early to prevent white artifacts
                        hologramColor *= verticalMask;
                        
                        // Add effects only where hologram is visible - keep dark
                        hologramColor *= 0.7; // Darken the base image
                        hologramColor += (depthTint * verticalMask);
                        hologramColor += (scanline + interference + speckle) * verticalMask * 0.5; // Reduce additive effects
                        hologramColor += (diffractionColor * verticalMask);
                        hologramColor *= fresnel;
                        
                        // Very subtle flickering
                        float flickerRate = 8.0 + layerDepth * 5.0;
                        float flickerIntensity = 0.02 + layerDepth * 0.01;
                        float flicker = (1.0 - flickerIntensity) + flickerIntensity * sin(time * flickerRate + interferencePhase);
                        
                        // Apply flickering
                        hologramColor *= flicker;
                        
                        // Enhanced edge distortion with Fresnel
                        float edgeDistort = diffraction * fresnel;
                        
                        // Apply vertical fade mask and ensure no white artifacts
                        float finalOpacity = alpha * opacity * edgeDistort * verticalMask;
                        
                        // Clamp colors to prevent white artifacts - fade to black only
                        vec3 finalColor = hologramColor * verticalMask;
                        finalColor = clamp(finalColor, vec3(0.0), vec3(0.8)); // Cap maximum brightness to prevent white
                        
                        gl_FragColor = vec4(finalColor, finalOpacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.NormalBlending
            });

            // Generate many layers for thick volumetric effect
            const layersData = [];
            const totalLayers = 25;
            const zRange = 6.0; // From +3 to -3
            const yRange = 0.4; // From -0.2 to +0.2
            
            for (let i = 0; i < totalLayers; i++) {
                const progress = i / (totalLayers - 1); // 0 to 1
                const z = 3.0 - progress * zRange; // Front to back (3 to -3)
                
                // Uniform opacity across all layers for thick, consistent volume
                const opacity = 0.7 + Math.sin(progress * Math.PI * 6) * 0.1; // 0.6 to 0.8 with subtle variation
                
                // Scale increases slightly towards back for perspective
                const scale = 1.0 + progress * 0.15;
                
                // Y position varies sinusoidally for organic layering
                const y = Math.sin(progress * Math.PI * 4) * yRange;
                
                // Interference phase spreads across all layers
                const interferencePhase = progress * 8.0;
                
                layersData.push({
                    opacity: opacity,
                    scale: scale,
                    z: z,
                    y: y,
                    interferencePhase: interferencePhase
                });
            }
            
            logoGroup = new THREE.Group();
            layersData.forEach((data, index) => {
                const material = hologramMaterial.clone();
                material.uniforms.opacity.value = data.opacity;
                material.uniforms.interferencePhase.value = data.interferencePhase;
                material.uniforms.layerDepth.value = Math.abs(data.z);
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(data.scale, data.scale, data.scale);
                mesh.position.z = data.z;
                mesh.position.y = data.y; // Add Y-axis layering
                
                // Add slight rotation offset for each layer to enhance 3D effect
                mesh.rotation.y = (index - layersData.length / 2) * 0.02;
                mesh.rotation.x = Math.sin(index) * 0.01;
                
                logoGroup.add(mesh);
            });
            scene.add(logoGroup);
        }

        function createFallbackHologram() {
            // Create a simple colored hologram when texture loading fails
            const aspectRatio = 1.0; // Square fallback
            const fov = camera.fov * Math.PI / 180;
            const distance = camera.position.z;
            const viewportHeight = 2 * Math.tan(fov / 2) * distance;
            const planeHeight = viewportHeight * 0.95;
            const planeWidth = planeHeight * aspectRatio;
            
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            
            // Simple colored material for fallback
            const fallbackMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    opacity: { value: 1.0 },
                    color: { value: new THREE.Color(0.3, 0.7, 1.0) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform vec3 color;
                    varying vec2 vUv;
                    
                    void main() {
                        // Simple holographic pattern
                        float pattern = sin(vUv.x * 10.0) * sin(vUv.y * 10.0) * 0.1 + 0.9;
                        vec3 finalColor = color * pattern;
                        gl_FragColor = vec4(finalColor, opacity);
                    }
                `,
                transparent: true
            });

            logoGroup = new THREE.Group();
            
            // Create just one layer for fallback
            const mesh = new THREE.Mesh(geometry, fallbackMaterial);
            logoGroup.add(mesh);
            
            scene.add(logoGroup);
        }

        function createAmbientParticles() {
            // Create subtle background particles for atmosphere
            const ambientParticleCount = 150;
            const ambientGeometry = new THREE.SphereGeometry(0.02, 4, 4);
            const ambientMaterial = new THREE.MeshBasicMaterial({
                color: 0x4080ff,
                transparent: true,
                opacity: 0.3
            });

            for (let i = 0; i < ambientParticleCount; i++) {
                const particle = new THREE.Mesh(ambientGeometry, ambientMaterial);
                
                // Random position in a large sphere
                const r = 20 + Math.random() * 30;
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * Math.PI * 2;
                particle.position.setFromSphericalCoords(r, phi, theta);
                
                // Store animation data
                particle.userData = {
                    originalPosition: particle.position.clone(),
                    drift: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    ),
                    phase: Math.random() * Math.PI * 2
                };
                
                scene.add(particle);
            }
        }

/**
         * Creates the proton particle system with random colors.
         */
         function createProtons() {
            protonGroup = new THREE.Group(); // Group to hold all protons

            // --- Define hologram-matching colors for the protons ---
            const protonColors = [
                0xFFFFFF, // White
                0x87CEFA, // LightSkyBlue
                0x00BFFF, // DeepSkyBlue
                0xAFEEEE, // PaleTurquoise
                0x7FFFD4, // Aquamarine
                0xB0E0E6  // PowderBlue
            ];

            // Shared geometry for efficiency (all protons are the same shape)
            const protonGeometry = new THREE.SphereGeometry(0.07, 8, 8);

            // --- Create each proton inside the loop ---
            for (let i = 0; i < protonCount; i++) {

                // 1. Select a random color from the palette
                const randomIndex = Math.floor(Math.random() * protonColors.length);
                const randomColor = protonColors[randomIndex];

                // 2. Create a UNIQUE material for this proton with the random color
                //    (Required because each needs a different color property)
                const protonMaterial = new THREE.MeshBasicMaterial({
                    color: randomColor,
                    transparent: true,
                    opacity: 0.9 + Math.random() * 0.3
                    // Example: opacity: 0.7 + Math.random() * 0.3
                });

                // 3. Create the mesh using shared geometry but unique material
                const protonMesh = new THREE.Mesh(protonGeometry, protonMaterial);

                // 4. Position the proton randomly within the sphere
                const r = Math.cbrt(Math.random()) * protonSphereRadius;
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * Math.PI * 2;
                protonMesh.position.setFromSphericalCoords(r, phi, theta);

                // 5. Store data needed for animation
                const protonData = {
                    mesh: protonMesh,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.6,
                        (Math.random() - 0.5) * 0.6,
                        (Math.random() - 0.5) * 0.6
                    ),
                    // Optional: Store the original color if needed later
                    // originalColor: randomColor
                };
                protons.push(protonData); // Add to array for animation access

                // 6. Add the individual proton mesh to the group
                protonGroup.add(protonMesh);
            }

            // Add the group containing all protons to the main scene
            scene.add(protonGroup);
        }

        function animateProtons(delta) {
             if (!protonGroup || !logoGroup) return;
             const speedFactor = delta * 8;
             const time = clock.getElapsedTime();
             const logoPos = logoGroup.position;
             
             // Get hologram power state for electromagnetic field strength
             const hologramPower = 0.9 + Math.sin(time * 8.7) * 0.1; // Same as power fluctuation
             
             protons.forEach((p, index) => {
                 // Calculate distance to hologram center
                 const distToLogo = p.mesh.position.distanceTo(logoPos);
                 const attractionZone = 6.0 * hologramPower; // Field strength varies with power
                 const repulsionZone = 2.0;
                 
                 // Enhanced electromagnetic field simulation
                 const fieldStrength = hologramPower * (attractionZone / (distToLogo + 0.5));
                 
                 // Apply attraction/repulsion forces with electromagnetic variations
                 if (distToLogo < attractionZone) {
                     const force = new THREE.Vector3().subVectors(logoPos, p.mesh.position);
                     
                     if (distToLogo < repulsionZone) {
                         // Repulsion - push away from center with electromagnetic pulses
                         const emPulse = 1.0 + Math.sin(time * 15.0 + index) * 0.3;
                         force.multiplyScalar(-0.8 * emPulse * fieldStrength / (distToLogo + 0.1));
                     } else {
                         // Attraction - pull towards center with field fluctuations
                         const fieldFluctuation = 1.0 + Math.sin(time * 12.0 + index * 2.0) * 0.2;
                         force.multiplyScalar(0.3 * fieldFluctuation * fieldStrength / distToLogo);
                     }
                     
                     p.velocity.add(force.multiplyScalar(delta));
                 }
                 
                 // Enhanced orbital motion with electromagnetic coupling
                 const orbitalForce = new THREE.Vector3()
                     .crossVectors(p.mesh.position, new THREE.Vector3(0, 1, 0))
                     .normalize()
                     .multiplyScalar(0.2 * delta * fieldStrength);
                 p.velocity.add(orbitalForce);
                 
                 // Electromagnetic interference between particles
                 protons.forEach((other, otherIndex) => {
                     if (index !== otherIndex) {
                         const particleDist = p.mesh.position.distanceTo(other.mesh.position);
                         if (particleDist < 1.5) {
                             const repelForce = new THREE.Vector3()
                                 .subVectors(p.mesh.position, other.mesh.position)
                                 .normalize()
                                 .multiplyScalar(0.1 / (particleDist + 0.1));
                             p.velocity.add(repelForce.multiplyScalar(delta));
                         }
                     }
                 });
                 
                 // Interference ripples when passing through hologram layers
                 const layerInterference = Math.abs(p.mesh.position.z - logoPos.z);
                 if (layerInterference < 3.0 && distToLogo < 8.0) {
                     // Create ripple effect in particle movement
                     const ripplePhase = time * 10.0 + index;
                     const rippleStrength = (3.0 - layerInterference) / 3.0;
                     const ripple = new THREE.Vector3(
                         Math.sin(ripplePhase) * rippleStrength * 0.05,
                         Math.cos(ripplePhase * 1.3) * rippleStrength * 0.05,
                         Math.sin(ripplePhase * 0.7) * rippleStrength * 0.03
                     );
                     p.velocity.add(ripple);
                     
                     // Light scattering effect - particles glow more when intersecting
                     const scatterIntensity = rippleStrength * 0.3;
                     p.mesh.material.opacity = Math.min(1.2, 0.9 + scatterIntensity);
                 } else {
                     // Return to normal opacity when not intersecting
                     p.mesh.material.opacity = THREE.MathUtils.lerp(
                         p.mesh.material.opacity, 
                         0.9 + Math.random() * 0.3, 
                         delta * 2.0
                     );
                 }
                 
                 // Respond to hologram power fluctuations
                 const powerResponse = 1.0 + (hologramPower - 1.0) * 0.5; // Damped response
                 
                 // Apply velocity with variable damping based on electromagnetic field
                 const damping = 0.98 - fieldStrength * 0.02;
                 p.velocity.multiplyScalar(damping);
                 p.mesh.position.addScaledVector(p.velocity, speedFactor * powerResponse);
                 
                 // Boundary check and reset
                 if (p.mesh.position.lengthSq() > protonSphereRadius * protonSphereRadius) {
                     const r = protonSphereRadius * (0.8 + Math.random() * 0.2);
                     const phi = Math.acos(-1 + (2 * Math.random()));
                     const theta = Math.random() * Math.PI * 2;
                     p.mesh.position.setFromSphericalCoords(r, phi, theta);
                     p.velocity.set(
                         (Math.random() - 0.5) * 0.4,
                         (Math.random() - 0.5) * 0.4,
                         (Math.random() - 0.5) * 0.4
                     );
                 }
                 
                 // Enhanced pulsing with electromagnetic coupling
                 const basePulse = 0.8 + 0.2 * Math.sin(time * 3.0 + p.mesh.position.x);
                 const emCoupling = 1.0 + fieldStrength * 0.1 * Math.sin(time * 20.0 + index);
                 p.mesh.scale.setScalar(basePulse * emCoupling);
             });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (logoGroup) { 
                // Apply floating motion without rotation
                // Primary drift motion with multiple frequency components
                logoGroup.position.y = Math.sin(time * 0.8) * 0.3 + Math.sin(time * 2.1) * 0.1;
                logoGroup.position.x = Math.cos(time * 0.6) * 0.2 + Math.sin(time * 1.7) * 0.08;
                logoGroup.position.z = Math.sin(time * 0.4) * 0.15;
                
                // Very subtle orientation variations (no rotation)
                logoGroup.rotation.x = Math.sin(time * 0.9) * 0.02 + Math.cos(time * 2.3) * 0.01;
                logoGroup.rotation.z = Math.cos(time * 1.1) * 0.015 + Math.sin(time * 1.8) * 0.008;
                
                // Magnetic field simulation - subtle warping
                const magneticPhase = time * 1.5;
                const magneticDistortion = 0.02;
                const magneticWarpX = Math.sin(magneticPhase) * magneticDistortion;
                const magneticWarpY = Math.cos(magneticPhase * 1.3) * magneticDistortion;
                logoGroup.rotation.x += magneticWarpX;
                logoGroup.rotation.z += magneticWarpY;
                
                // Vertical fade turned off - hologram stays fully visible
                const verticalFadePosition = 1.0; // Always fully visible
                
                // Distortion turned off
                const distortionAmount = 0.0;
                
                // Update shader time uniforms and add layer-specific animations with parallax
                logoGroup.children.forEach((mesh, index) => {
                        if (mesh.material.uniforms && mesh.material.uniforms.time) {
                            mesh.material.uniforms.time.value = time;
                        }
                        
                        // Apply vertical fade effect to each layer
                        if (mesh.material.uniforms.verticalFade) {
                            mesh.material.uniforms.verticalFade.value = verticalFadePosition;
                        }
                        
                        // Apply distortion effect
                        if (mesh.material.uniforms.distortionAmount) {
                            mesh.material.uniforms.distortionAmount.value = distortionAmount;
                        }
                    
                    // Calculate layer depth for parallax effect
                    const totalLayers = logoGroup.children.length;
                    const layerDepth = (index / (totalLayers - 1)) * 6.0 - 3.0; // -3 to +3
                    const layerPhase = index * 0.3;
                    
                    
                    // Parallax effect based on virtual camera movement
                    const cameraInfluence = 0.15; // How much camera affects parallax
                    const virtualCameraX = Math.sin(time * 0.7) * 2.0; // Virtual camera movement
                    const virtualCameraY = Math.cos(time * 0.5) * 1.5;
                    
                    // Layers at different depths shift differently (closer layers move more)
                    const parallaxFactorX = (layerDepth + 3.0) / 6.0; // 0 to 1 (back to front)
                    const parallaxFactorY = (layerDepth + 3.0) / 6.0;
                    
                    const parallaxOffsetX = virtualCameraX * parallaxFactorX * cameraInfluence;
                    const parallaxOffsetY = virtualCameraY * parallaxFactorY * cameraInfluence;
                    
                    // Individual layer floating with parallax
                    mesh.position.y = Math.sin(time * 0.6 + layerPhase) * 0.05 + parallaxOffsetY;
                    mesh.position.x = Math.cos(time * 0.4 + layerPhase) * 0.03 + parallaxOffsetX;
                    
                    // Depth-based rotation variance (front layers rotate more)
                    const rotationFactor = 1.0 + parallaxFactorX * 0.5;
                    mesh.rotation.z = Math.sin(time * 0.3 + layerPhase) * 0.008 * rotationFactor;
                    
                    // Depth-based perspective shift
                    const perspectiveShift = Math.sin(time * 0.8 + layerPhase) * parallaxFactorX * 0.02;
                    mesh.rotation.y = perspectiveShift;
                    mesh.rotation.x = Math.cos(time * 0.9 + layerPhase) * parallaxFactorX * 0.015;
                    
                    // Pulsing scale effect with depth variation
                    const depthPulse = 1.0 + Math.sin(time * 2.0 + layerPhase + layerDepth) * 0.005;
                    mesh.scale.setScalar(mesh.scale.x * depthPulse / (mesh.scale.x || 1.0));
                    
                    // Holographic instabilities - glitches, power fluctuations, interference
                    const glitchTrigger = Math.sin(time * 0.13) * Math.cos(time * 0.17);
                    const isGlitching = glitchTrigger > 0.85;
                    
                    if (isGlitching) {
                        // Layer displacement during glitches
                        const glitchIntensity = (glitchTrigger - 0.85) / 0.15;
                        mesh.position.x += (Math.random() - 0.5) * 0.3 * glitchIntensity;
                        mesh.position.y += (Math.random() - 0.5) * 0.2 * glitchIntensity;
                        mesh.position.z += (Math.random() - 0.5) * 0.1 * glitchIntensity;
                        
                        // Rotation glitches
                        mesh.rotation.z += (Math.random() - 0.5) * 0.1 * glitchIntensity;
                        mesh.rotation.y += (Math.random() - 0.5) * 0.05 * glitchIntensity;
                    }
                    
                    // Power fluctuations affecting individual layers
                    const powerCycle = Math.sin(time * 0.3) * 0.5 + 0.5;
                    const powerFluctuation = 0.9 + Math.sin(time * 8.7) * 0.1 * powerCycle;
                    
                    // Signal loss moments (some layers temporarily have reduced opacity)
                    const signalLoss = Math.sin(time * 0.11 + index) > 0.92;
                    const signalLossOpacity = signalLoss ? 0.1 : 1.0;
                    
                    // Electromagnetic interference patterns
                    const emInterference = Math.sin(time * 12.3 + index * 2.1) * 
                                         Math.cos(time * 15.7 + layerDepth);
                    if (mesh.material.uniforms.interferenceIntensity) {
                        const baseInterference = 0.003;
                        mesh.material.uniforms.interferenceIntensity.value = 
                            baseInterference + Math.abs(emInterference) * 0.008;
                    }
                    });
                
            }
            animateProtons(delta);
            animateAmbientParticles(time);
            composer.render(delta);
        }

        function animateAmbientParticles(time) {
            // Animate background ambient particles
            scene.children.forEach(child => {
                if (child.userData && child.userData.drift) {
                    // Gentle floating motion
                    child.position.copy(child.userData.originalPosition);
                    child.position.add(child.userData.drift.clone().multiplyScalar(time));
                    
                    // Add subtle pulsing
                    const pulse = 0.5 + 0.5 * Math.sin(time * 0.5 + child.userData.phase);
                    child.material.opacity = 0.1 + 0.2 * pulse;
                    
                    // Slow rotation
                    child.rotation.y = time * 0.1 + child.userData.phase;
                }
            });
        }

        function displayLoadError(message) {
             const errorDiv = document.createElement('div');
             errorDiv.style.cssText = 'color: black; background-color: rgba(255, 100, 100, 0.8); padding: 15px; position: absolute; top: 10px; left: 10px; z-index: 1000; font-family: sans-serif; border-radius: 5px;';
             errorDiv.innerHTML = message;
             document.body.appendChild(errorDiv);
        }

        function validateLicense() {
            const auditKey = "cyberhaven-license-checksum";
            const hash = btoa(unescape(encodeURIComponent("C7-THN-99321-PROTOTYPE")));
            if (hash !== "QzctVEhOLTk5MzIxLVBST1RPVFlQRQ==") {
                console.error("License validation failed.");
                throw new Error("Unauthorized deployment detected.");
            }
        }

        validateLicense();

        init(); // Start the application

    </script>
</body>
</html>